import dotenv from 'dotenv';
import { MongoClient, ObjectId } from 'mongodb';
import { createEmbedding } from '../../utils/createEmbeddings';
import { hitOpenAiApi, hitOpenAiApiNew, hitOpenAiApiTest } from '../../openai';
import { IEvent } from './models/Event';

dotenv.config();

const retrievalPrompt = `
You are a professional IT specialist who can structure all the technical imformations of event into a structured format. Please provide the following information about event in an unstructured text, and then convert it into the structured JSON format provided below:

Unstructured Information:
"
   {
        "_id": "66a204e1da55709bddff6ede",
        "url": "https://clck.ru/3AsP7o",
        "description": "#LastCall

–£–∂–µ –∑–∞–≤—Ç—Ä–∞ –ø–æ–¥–æ–π–¥—ë—Ç –∫ –∫–æ–Ω—Ü—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ —Ö–∞–∫–∞—Ç–æ–Ω Hack.Genesis –æ—Ç –∫–æ–º–∞–Ω–¥—ã Phystech.Genesis –ø—Ä–∏ –ø–∞—Ä—Ç–Ω—ë—Ä—Å—Ç–≤–µ —Å –ú–æ—Å–±–∏—Ä–∂–µ–π. –£—Å–ø–µ–π –ø–æ–¥–∞—Ç—å –∑–∞—è–≤–∫—É!‚ö°Ô∏è

üîπ–§–æ—Ä–º–∞—Ç: –æ–Ω–ª–∞–π–Ω;
üîπ–î–∞—Ç—ã –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è: 31 –º–∞—è ‚Äì 2 –∏—é–Ω—è;
üîπ–ü—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥: 250.000 —Ä—É–±–ª–µ–π.

–í —Ä–∞–º–∫–∞—Ö —Ö–∞–∫–∞—Ç–æ–Ω–∞ —Ç–µ–±–µ –±—É–¥–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–æ —Å–æ–∑–¥–∞—Ç—å —Å–∏—Å—Ç–µ–º—É, –ø–æ–º–æ–≥–∞—é—â—É—é —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è –≤ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö —Å –ø–æ–º–æ—â—å—é –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π.

üôå –ú—ã –∂–¥—ë–º —Ç–µ–±—è, –µ—Å–ª–∏ —Ç—ã:
‚Äì –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫;
‚Äì –ê–Ω–∞–ª–∏—Ç–∏–∫ –¥–∞–Ω–Ω—ã—Ö;
‚Äì –ü—Ä–æ–¥—É–∫—Ç–æ–ª–æ–≥.

Hack.Genesis 2024 ‚Äì —ç—Ç–æ:
‚Äì –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ—Ä–∞–±–æ—Ç–∞—Ç—å —Å –æ–ø—ã—Ç–Ω—ã–º–∏ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞–º–∏;
‚Äì 40-—á–∞—Å–æ–≤–æ–µ —Å–æ—Ä–µ–≤–Ω–æ–≤–∞–Ω–∏–µ —Å –¥—Ä—É–≥–∏–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏;
‚Äì –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ–Ω–µ–∂–Ω—ã–µ –∏ —Ü–µ–Ω–Ω—ã–µ –ø—Ä–∏–∑—ã.


‚ùóÔ∏è–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ –¥–æ 28 –º–∞—è 23:59, –ú–°–ö –ø–æ —Å—Å—ã–ª–∫–µ: https://clck.ru/3AsP7o",
        "title": "#LastCall",
        "themes": []
    }
"

Structured JSON Format:
"
{
  "_id": "66a204e1da55709bddff6ede",
  "url": "https://clck.ru/3AsP7o",
  "description": "#LastCall

–£–∂–µ –∑–∞–≤—Ç—Ä–∞ –ø–æ–¥–æ–π–¥—ë—Ç –∫ –∫–æ–Ω—Ü—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ —Ö–∞–∫–∞—Ç–æ–Ω Hack.Genesis –æ—Ç –∫–æ–º–∞–Ω–¥—ã Phystech.Genesis –ø—Ä–∏ –ø–∞—Ä—Ç–Ω—ë—Ä—Å—Ç–≤–µ —Å –ú–æ—Å–±–∏—Ä–∂–µ–π. –£—Å–ø–µ–π –ø–æ–¥–∞—Ç—å –∑–∞—è–≤–∫—É!‚ö°Ô∏è

üîπ–§–æ—Ä–º–∞—Ç: –æ–Ω–ª–∞–π–Ω;
üîπ–î–∞—Ç—ã –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è: 31 –º–∞—è ‚Äì 2 –∏—é–Ω—è;
üîπ–ü—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥: 250.000 —Ä—É–±–ª–µ–π.

–í —Ä–∞–º–∫–∞—Ö —Ö–∞–∫–∞—Ç–æ–Ω–∞ —Ç–µ–±–µ –±—É–¥–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–æ —Å–æ–∑–¥–∞—Ç—å —Å–∏—Å—Ç–µ–º—É, –ø–æ–º–æ–≥–∞—é—â—É—é —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è –≤ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö —Å –ø–æ–º–æ—â—å—é –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π.

üôå –ú—ã –∂–¥—ë–º —Ç–µ–±—è, –µ—Å–ª–∏ —Ç—ã:
‚Äì –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫;
‚Äì –ê–Ω–∞–ª–∏—Ç–∏–∫ –¥–∞–Ω–Ω—ã—Ö;
‚Äì –ü—Ä–æ–¥—É–∫—Ç–æ–ª–æ–≥.

Hack.Genesis 2024 ‚Äì —ç—Ç–æ:
‚Äì –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ—Ä–∞–±–æ—Ç–∞—Ç—å —Å –æ–ø—ã—Ç–Ω—ã–º–∏ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞–º–∏;
‚Äì 40-—á–∞—Å–æ–≤–æ–µ —Å–æ—Ä–µ–≤–Ω–æ–≤–∞–Ω–∏–µ —Å –¥—Ä—É–≥–∏–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏;
‚Äì –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ–Ω–µ–∂–Ω—ã–µ –∏ —Ü–µ–Ω–Ω—ã–µ –ø—Ä–∏–∑—ã.


‚ùóÔ∏è–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ –¥–æ 28 –º–∞—è 23:59, –ú–°–ö –ø–æ —Å—Å—ã–ª–∫–µ: https://clck.ru/3AsP7o",

  "title": "Hack.Genesis",
  "date": "31.05.2024",
  "category": "Hackathon",
}"

Please transform the unstructured information into the structured JSON format provided.
`;

class EventService {
  private client: MongoClient;

  constructor() {
    this.client = new MongoClient(process.env.MONGODB_URL || 'mongodb://localhost:27017');
  }

  async getAllEvents(page: number, limit: number) {
    const skip = (page - 1) * limit;

    try {
      await this.client.connect();

      const db = this.client.db('main');
      const collection = db.collection('events');

      const events = await collection.find({}, {
        projection: {
          _id: 1,
          title: 1,
          'displayed_location.location': 1,
          thumbnail_url: 1,
          url: 1,
          prize_amount: 1,
        }
      })
      .skip(skip)
      .limit(limit)
      .toArray();

      return events;
    } catch (err) {
      console.error('Error fetching events:', err);
      throw new Error('Internal server error');
    } finally {
      await this.client.close();
    }
  }

  async getEventById(eventId: string) {
    try {
      await this.client.connect();

      const db = this.client.db('main');
      const collection = db.collection('events');

      const event = await collection.findOne({ _id: new ObjectId(eventId) });

      if (!event) {
        throw new Error('Event not found');
      }

      return event;
    } catch (err) {
      console.error('Error fetching event by ID:', err);
      throw new Error('Internal server error');
    } finally {
      await this.client.close();
    }
  }

  async getEventByUrl(eventUrl: string) {
    try {
      await this.client.connect();

      const db = this.client.db('main');
      const collection = db.collection('events');

      const event = await collection.findOne({ url: eventUrl });

      if (!event) {
        throw new Error('Event not found');
      }

      return event;
    } catch (err) {
      console.error('Error fetching event by URL:', err);
      throw new Error('Internal server error');
    } finally {
      await this.client.close();
    }
  }


//   async getSuitableEvents(query: string) {
//     try {
//       await this.client.connect();
//       const db = this.client.db('main');
//       const collection = db.collection('events');
  
//       const embedding = await createEmbedding(query);
//       if (!embedding) {
//         throw new Error('Failed to create embedding');
//       }
  
//       const events = await collection.aggregate([
//         {
//          '$vectorSearch': {
//                 'index': 'default', 
//                 'path': 'embedding', 
//                 'queryVector': embedding, 
//             'numCandidates': 150, 
//                 'limit': 10
//           }
//         },
//         {
//           $project: {
//             _id: 1,
//             title: 1,
//             description: 1,
//             displayed_location: 1,
//             open_state: 1,
//             thumbnail_url: 1,
//             analytics_identifier: 1,
//             url: 1,
//             time_left_to_submission: 1,
//             submission_period_dates: 1,
//             themes: { $map: { input: "$themes", as: "theme", in: { name: "$$theme.name" } } },
//             prize_amount: 1,
//             registrations_count: 1,
//             featured: 1,
//             organization_name: 1,
//             winners_announced: 1,
//             submission_gallery_url: 1,
//             start_a_submission_url: 1,
//             invite_only: 1,
//             eligibility_requirement_invite_only_description: 1,
//             managed_by_devpost_badge: 1,
//             score: { $meta: 'searchScore' },
//           }
//         }
//       ]).toArray();
  
//       const topEvents = events.sort((a, b) => b.score - a.score);
  
//       const prompt = `–°–ø–∏—Å–æ–∫ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö IT –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ "${query}":
//         ${topEvents.map(event => `–ù–∞–∑–≤–∞–Ω–∏–µ: ${event.title}
//         –õ–æ–∫–∞—Ü–∏—è: ${event.displayed_location}
//         –°—Ç–∞—Ç—É—Å: ${event.open_state}
//         –°—Ä–æ–∫ –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–æ–∫: ${event.time_left_to_submission}
//         –ü—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥: ${event.prize_amount}
//         URL: ${event.url}`).join('\n\n')
//       }
  
//       –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ —Å–∞–º—ã–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –∏ —É–∫–∞–∂–∏, –ø–æ—á–µ–º—É –æ–Ω–∏ –ª—É—á—à–µ –≤—Å–µ–≥–æ –ø–æ–¥—Ö–æ–¥—è—Ç –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
//       –û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç—Ä–æ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON –º–∞—Å—Å–∏–≤–∞ –∏ –Ω–µ –¥–æ–ª–∂–µ–Ω –≤–∫–ª—é—á–∞—Ç—å –Ω–∏–∫–∞–∫–æ–≥–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.
//       JSON –º–∞—Å—Å–∏–≤ –¥–æ–ª–∂–µ–Ω –≤—ã–≥–ª—è–¥–µ—Ç—å —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º –∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω –¥–∞–Ω–Ω—ã–º–∏ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è:
//       [
//           {
//               _id: _id –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è,
//               title: –ù–∞–∑–≤–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è,
//               displayed_location: –õ–æ–∫–∞—Ü–∏—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è,
//               open_state: ,
//               thumbnail_url: ,
//               url: ,
//               time_left_to_submission: ,
//               submission_period_dates: ,
//               prize_amount: ,
//               registrations_count: ,
//               featured: ,
//               organization_name: ,
//               themes: [ {
//                   "id": ,
//                   "name": ,
//                   "_id": 
//               },
//               {
//                   "id": ,
//                   "name": ,
//                   "_id": 
//               },
//               {
//                   "id": ,
//                   "name": ,
//                   "_id": 
//               } ],
//               score: 
//           }
//       ]`;
  
//       const selectedEvents = await hitOpenAiApiTest(prompt);
  
//       return { topEvents, selectedEvents };
//     } catch (err) {
//       console.error('Error fetching suitable events:', err);
//       throw new Error('Internal server error');
//     } finally {
//       await this.client.close();
//     }
//   }

async getTopEvents(query: string) {
  try {
    await this.client.connect();
    const db = this.client.db('main');
    const collection = db.collection('events');

    const embedding = await createEmbedding(query);
    if (!embedding) {
      throw new Error('Failed to create embedding');
    }

    const currentDate = new Date();

    const events = await collection.aggregate([
      {
        '$vectorSearch': {
          'index': 'default',
          'path': 'embedding',
          'queryVector': embedding,
          'numCandidates': 150,
          'limit': 20
        }
      },
      {
        $project: {
          _id: 1,
          title: 1,
          description: 1,
          displayed_location: 1,
          open_state: 1,
          thumbnail_url: 1,
          url: 1,
          time_left_to_submission: 1,
          submission_period_dates: 1,
          themes: { $map: { input: "$themes", as: "theme", in: { name: "$$theme.name" } } },
          prize_amount: 1,
          registrations_count: 1,
          featured: 1,
          organization_name: 1,
          winners_announced: 1,
          submission_gallery_url: 1,
          start_a_submission_url: 1,
          invite_only: 1,
          eligibility_requirement_invite_only_description: 1,
          managed_by_devpost_badge: 1,
          score: { $meta: 'searchScore' },
        }
      }
    ]).toArray();

    console.log('Fetched events:', events);

    const topEvents = events.sort((a, b) => b.score - a.score);

    return topEvents;
  } catch (err) {
    console.error('Error fetching top events:', err);
    throw new Error('Internal server error');
  } finally {
    await this.client.close();
  }
}

async getSuitableEvents(query: string) {
  try {
    const topEvents = await this.getTopEvents(query);

    if (!topEvents || topEvents.length === 0) {
      console.log('No events found after query.');
      return { topEvents: [], selectedEvents: [] };
    }

    const response = await hitOpenAiApiNew(query, topEvents);

    if (!response) {
      throw new Error('Failed to get a valid response from OpenAI API');
    }

    // Extract JSON content from the response
    const jsonResponseMatch = response.match(/```json\n([\s\S]*?)\n```/);
    if (!jsonResponseMatch) {
      throw new Error('Invalid JSON format in the response');
    }

    const jsonResponse = jsonResponseMatch[1];
    const selectedEvents = JSON.parse(jsonResponse);

    return {
      topEvents,
      selectedEvents
    };
  } catch (err) {
    console.error('Error getting suitable events:', err);
    throw new Error('Internal server error');
  }
}

  
  
}


export default EventService;
